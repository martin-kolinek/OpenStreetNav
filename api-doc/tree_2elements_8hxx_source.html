<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>

<title>/home/martin/workspace/OpenStreetNav/xmlschema/libxsd/xsd/cxx/tree/elements.hxx Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/martin/workspace/OpenStreetNav/xmlschema/libxsd/xsd/cxx/tree/elements.hxx</div>  </div>
</div>
<div class="contents">
<a href="tree_2elements_8hxx.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// file      : xsd/cxx/tree/elements.hxx</span>
<a name="l00002"></a>00002 <span class="comment">// author    : Boris Kolpackov &lt;boris@codesynthesis.com&gt;</span>
<a name="l00003"></a>00003 <span class="comment">// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC</span>
<a name="l00004"></a>00004 <span class="comment">// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file</span>
<a name="l00005"></a>00005 
<a name="l00017"></a>00017 <span class="preprocessor">#ifndef XSD_CXX_TREE_ELEMENTS_HXX</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span><span class="preprocessor">#define XSD_CXX_TREE_ELEMENTS_HXX</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;memory&gt;</span>  <span class="comment">// std::auto_ptr</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;istream&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;xercesc/dom/DOMNode.hpp&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;xercesc/dom/DOMAttr.hpp&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;xercesc/dom/DOMElement.hpp&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;xercesc/dom/DOMDocument.hpp&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;xercesc/dom/DOMNamedNodeMap.hpp&gt;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="xml_2elements_8hxx.html">xsd/cxx/xml/elements.hxx</a>&gt;</span> <span class="comment">// xml::properties</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="auto-ptr_8hxx.html">xsd/cxx/xml/dom/auto-ptr.hxx</a>&gt;</span> <span class="comment">// dom::auto_ptr</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;<a class="code" href="facet_8hxx.html">xsd/cxx/tree/facet.hxx</a>&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;<a class="code" href="tree_2exceptions_8hxx.html" title="Contains exception definitions for the C++/Tree mapping.">xsd/cxx/tree/exceptions.hxx</a>&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;<a class="code" href="istream-fwd_8hxx.html">xsd/cxx/tree/istream-fwd.hxx</a>&gt;</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="keyword">namespace </span>xsd
<a name="l00041"></a>00041 {
<a name="l00042"></a>00042   <span class="keyword">namespace </span>cxx
<a name="l00043"></a>00043   {
<a name="l00052"></a>00052     <span class="keyword">namespace </span>tree
<a name="l00053"></a>00053     {
<a name="l00062"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html">00062</a>       <span class="keyword">class </span><a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a>
<a name="l00063"></a>00063       {
<a name="l00064"></a>00064       <span class="keyword">public</span>:
<a name="l00069"></a>00069 
<a name="l00073"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#a16ddf5aae8d451ab90e25105bf7df143">00073</a>         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#a16ddf5aae8d451ab90e25105bf7df143" title="Keep DOM association in the resulting tree.">keep_dom</a> = 0x00000100UL;
<a name="l00074"></a>00074 
<a name="l00083"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#aa7ecf933d8b310b3d239186c0f904b1b">00083</a>         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#aa7ecf933d8b310b3d239186c0f904b1b" title="Assume ownership of the DOM document.">own_dom</a> = 0x00000200UL;
<a name="l00084"></a>00084 
<a name="l00089"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#aeec1e2271c81bc5fa1be8bd57ae1e07c">00089</a>         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#aeec1e2271c81bc5fa1be8bd57ae1e07c" title="Turn off XML Schema validation in the underlying XML parser.">dont_validate</a> = 0x00000400UL;
<a name="l00090"></a>00090 
<a name="l00094"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#a2528b066da6dfb419dc5f60f41ce6b66">00094</a>         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#a2528b066da6dfb419dc5f60f41ce6b66" title="Do not initialize the Xerces-C++ runtime.">dont_initialize</a> = 0x00000001UL;
<a name="l00095"></a>00095 
<a name="l00099"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#a4be5ff3a2ce3fe276b71861838bb980a">00099</a>         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#a4be5ff3a2ce3fe276b71861838bb980a" title="Do not write XML declaration during serialization.">no_xml_declaration</a> = 0x00010000UL;
<a name="l00100"></a>00100 
<a name="l00105"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#a73f5deba6d903151cdba1ca743e1c868">00105</a>         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#a73f5deba6d903151cdba1ca743e1c868" title="Do not add extra spaces or new lines that make the resulting XML easier to read.">dont_pretty_print</a> = 0x00020000UL;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         <span class="comment">//@cond</span>
<a name="l00108"></a>00108 
<a name="l00109"></a>00109         <span class="comment">// The following flags are for internal use.</span>
<a name="l00110"></a>00110         <span class="comment">//</span>
<a name="l00111"></a>00111         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="structbase.html">base</a> = 0x01000000UL;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113         <span class="comment">//@endcond</span>
<a name="l00114"></a>00114 
<a name="l00115"></a>00115         <span class="comment">// Notes on flag blocks:</span>
<a name="l00116"></a>00116         <span class="comment">//</span>
<a name="l00117"></a>00117         <span class="comment">// 0x000000FF - common (applicable to both parsing and serialization)</span>
<a name="l00118"></a>00118         <span class="comment">// 0x0000FF00 - parsing (values aligned with XML parsing)</span>
<a name="l00119"></a>00119         <span class="comment">// 0x00FF0000 - serialization (values aligned with XML serialization)</span>
<a name="l00120"></a>00120         <span class="comment">// 0xFF000000 - internal</span>
<a name="l00121"></a>00121 
<a name="l00123"></a>00123 
<a name="l00124"></a>00124       <span class="keyword">public</span>:
<a name="l00130"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#ac50b80766ab922360182e8f573293a8a">00130</a>         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#ac50b80766ab922360182e8f573293a8a" title="Initialize an instance with an integer value.">flags</a> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> x = 0)
<a name="l00131"></a>00131             : x_ (x)
<a name="l00132"></a>00132         {
<a name="l00133"></a>00133         }
<a name="l00134"></a>00134 
<a name="l00140"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#ac97ca7282a797404cd983ce2087a15b0">00140</a>         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#ac97ca7282a797404cd983ce2087a15b0" title="Convert an instance to an integer value.">operator unsigned long </a>()<span class="keyword"> const</span>
<a name="l00141"></a>00141 <span class="keyword">        </span>{
<a name="l00142"></a>00142           <span class="keywordflow">return</span> x_;
<a name="l00143"></a>00143         }
<a name="l00144"></a>00144 
<a name="l00150"></a>00150         <span class="keyword">friend</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a>
<a name="l00151"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#a99bae0c8e09870349ca2d0f062e09580">00151</a>         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#a99bae0c8e09870349ca2d0f062e09580" title="Combine two flags.">operator| </a>(<span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a>&amp; a, <span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a>&amp; b)
<a name="l00152"></a>00152         {
<a name="l00153"></a>00153           <span class="keywordflow">return</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#ac50b80766ab922360182e8f573293a8a" title="Initialize an instance with an integer value.">flags</a> (a.x_ | b.x_);
<a name="l00154"></a>00154         }
<a name="l00155"></a>00155 
<a name="l00161"></a>00161         <span class="keyword">friend</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a>
<a name="l00162"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#a8c967b2962e5235c0fa0e1a9cd099630">00162</a>         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#a99bae0c8e09870349ca2d0f062e09580" title="Combine two flags.">operator| </a>(<span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a>&amp; a, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> b)
<a name="l00163"></a>00163         {
<a name="l00164"></a>00164           <span class="keywordflow">return</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#ac50b80766ab922360182e8f573293a8a" title="Initialize an instance with an integer value.">flags</a> (a.x_ | b);
<a name="l00165"></a>00165         }
<a name="l00166"></a>00166 
<a name="l00172"></a>00172         <span class="keyword">friend</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a>
<a name="l00173"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#a495100bed86260ac1cdb33e7c746ff33">00173</a>         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#a99bae0c8e09870349ca2d0f062e09580" title="Combine two flags.">operator| </a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> a, <span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a>&amp; b)
<a name="l00174"></a>00174         {
<a name="l00175"></a>00175           <span class="keywordflow">return</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html#ac50b80766ab922360182e8f573293a8a" title="Initialize an instance with an integer value.">flags</a> (a | b.x_);
<a name="l00176"></a>00176         }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178       <span class="keyword">private</span>:
<a name="l00179"></a>00179         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> x_;
<a name="l00180"></a>00180       };
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 
<a name="l00183"></a>00183       <span class="comment">// Parsing properties. Refer to xsd/cxx/xml/elements.hxx for XML-</span>
<a name="l00184"></a>00184       <span class="comment">// related properties.</span>
<a name="l00185"></a>00185       <span class="comment">//</span>
<a name="l00186"></a>00186       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;
<a name="l00187"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1properties.html">00187</a>       <span class="keyword">class </span><a class="code" href="classxsd_1_1cxx_1_1tree_1_1properties.html">properties</a>: <span class="keyword">public</span> xml::<a class="code" href="classxsd_1_1cxx_1_1tree_1_1properties.html">properties</a>&lt;C&gt;
<a name="l00188"></a>00188       {
<a name="l00189"></a>00189       };
<a name="l00190"></a>00190 
<a name="l00191"></a>00191       <span class="comment">//@cond</span>
<a name="l00192"></a>00192 
<a name="l00193"></a>00193       <span class="comment">// DOM user data keys.</span>
<a name="l00194"></a>00194       <span class="comment">//</span>
<a name="l00195"></a>00195       <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dummy&gt;
<a name="l00196"></a>00196       <span class="keyword">struct </span>user_data_keys_template
<a name="l00197"></a>00197       {
<a name="l00198"></a>00198         <span class="comment">// Back pointers to tree nodes.</span>
<a name="l00199"></a>00199         <span class="comment">//</span>
<a name="l00200"></a>00200         <span class="keyword">static</span> <span class="keyword">const</span> XMLCh node[21];
<a name="l00201"></a>00201       };
<a name="l00202"></a>00202 
<a name="l00203"></a>00203       <span class="keyword">typedef</span> user_data_keys_template&lt;0&gt; user_data_keys;
<a name="l00204"></a>00204 
<a name="l00205"></a>00205       <span class="comment">// HP aCC3 complains about unresolved symbols without an explicit</span>
<a name="l00206"></a>00206       <span class="comment">// instantiation.</span>
<a name="l00207"></a>00207       <span class="comment">//</span>
<a name="l00208"></a>00208 <span class="preprocessor">#if defined(__HP_aCC) &amp;&amp; __HP_aCC &lt;= 39999</span>
<a name="l00209"></a>00209 <span class="preprocessor"></span>      <span class="keyword">template</span> <span class="keyword">struct </span>user_data_keys_template&lt;0&gt;;
<a name="l00210"></a>00210 <span class="preprocessor">#endif</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span>      <span class="comment">//</span>
<a name="l00212"></a>00212       <span class="comment">//</span>
<a name="l00213"></a>00213       <span class="keyword">struct </span>identity
<a name="l00214"></a>00214       {
<a name="l00215"></a>00215         <span class="keyword">virtual</span>
<a name="l00216"></a>00216         ~identity ()
<a name="l00217"></a>00217         {
<a name="l00218"></a>00218         }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220         identity ()
<a name="l00221"></a>00221         {
<a name="l00222"></a>00222         }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224         <span class="keyword">virtual</span> <span class="keywordtype">bool</span>
<a name="l00225"></a>00225         before (<span class="keyword">const</span> identity&amp;) <span class="keyword">const</span> = 0;
<a name="l00226"></a>00226 
<a name="l00227"></a>00227         <span class="keyword">virtual</span> <span class="keywordtype">void</span>
<a name="l00228"></a>00228         throw_duplicate_id () <span class="keyword">const</span> = 0;
<a name="l00229"></a>00229 
<a name="l00230"></a>00230       <span class="keyword">private</span>:
<a name="l00231"></a>00231         identity (<span class="keyword">const</span> identity&amp;);
<a name="l00232"></a>00232 
<a name="l00233"></a>00233         identity&amp;
<a name="l00234"></a>00234         operator= (<span class="keyword">const</span> identity&amp;);
<a name="l00235"></a>00235       };
<a name="l00236"></a>00236 
<a name="l00237"></a>00237       <span class="comment">//@endcond</span>
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 
<a name="l00240"></a>00240       <span class="comment">// anyType. VC++ has a name injection bug that makes it impossible</span>
<a name="l00241"></a>00241       <span class="comment">// to have a member with the same name as a base type. To address</span>
<a name="l00242"></a>00242       <span class="comment">// that we will have to choose some unique name for the definition</span>
<a name="l00243"></a>00243       <span class="comment">// and typedef it to &#39;type&#39;.</span>
<a name="l00244"></a>00244       <span class="comment">//</span>
<a name="l00245"></a><a class="code" href="namespacexsd_1_1cxx_1_1tree.html#ab1cb97634544f0807153eb2ca9696514">00245</a>       <span class="keyword">class </span><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">_type</a>;
<a name="l00246"></a>00246 
<a name="l00251"></a>00251       <span class="keyword">typedef</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">_type</a> <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#ab1cb97634544f0807153eb2ca9696514" title="Class corresponding to the XML Schema anyType built-in type.">type</a>;
<a name="l00252"></a>00252 
<a name="l00257"></a><a class="code" href="namespacexsd_1_1cxx_1_1tree.html#af4fa7fc8c640fbce1676e7743f2f08bc">00257</a>       <span class="keyword">typedef</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">_type</a> <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#af4fa7fc8c640fbce1676e7743f2f08bc" title="Container type.">container</a>;
<a name="l00258"></a>00258 
<a name="l00267"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html">00267</a>       <span class="keyword">class </span><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">_type</a>
<a name="l00268"></a>00268       {
<a name="l00269"></a>00269       <span class="keyword">public</span>:
<a name="l00270"></a>00270         <span class="keyword">virtual</span>
<a name="l00271"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#a9251107be5b6c8864be9a739a3eec88b">00271</a>         ~<a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">_type</a> ()
<a name="l00272"></a>00272         {
<a name="l00273"></a>00273           <span class="comment">// Everything should have been unregistered by now.</span>
<a name="l00274"></a>00274           <span class="comment">//</span>
<a name="l00275"></a>00275           assert (map_.get () == 0 || map_-&gt;size () == 0);
<a name="l00276"></a>00276         }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278       <span class="keyword">public</span>:
<a name="l00283"></a>00283 
<a name="l00287"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#aa0e28b25c653f7eca226d0e0a5e70816">00287</a>         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">_type</a> ()
<a name="l00288"></a>00288             : container_ (0)
<a name="l00289"></a>00289         {
<a name="l00290"></a>00290         }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292       <span class="keyword">public</span>:
<a name="l00302"></a>00302         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">_type</a> (<span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">type</a>&amp; x, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0);
<a name="l00303"></a>00303 
<a name="l00315"></a>00315         <span class="keyword">virtual</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">type</a>*
<a name="l00316"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#ab428e8ac3905c42c7052f71f8504bbf3">00316</a>         _clone (<a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0)<span class="keyword"> const</span>
<a name="l00317"></a>00317 <span class="keyword">        </span>{
<a name="l00318"></a>00318           <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#ab1cb97634544f0807153eb2ca9696514" title="Class corresponding to the XML Schema anyType built-in type.">type</a> (*<span class="keyword">this</span>, f, c);
<a name="l00319"></a>00319         }
<a name="l00320"></a>00320 
<a name="l00321"></a>00321       <span class="keyword">public</span>:
<a name="l00331"></a>00331         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S&gt;
<a name="l00332"></a>00332         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">_type</a> (<a class="code" href="classxsd_1_1cxx_1_1tree_1_1istream.html">istream&lt;S&gt;</a>&amp; s, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0);
<a name="l00333"></a>00333 
<a name="l00342"></a>00342         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">_type</a> (<span class="keyword">const</span> xercesc::DOMElement&amp; e, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0);
<a name="l00343"></a>00343 
<a name="l00352"></a>00352         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">_type</a> (<span class="keyword">const</span> xercesc::DOMAttr&amp; a, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0);
<a name="l00353"></a>00353 
<a name="l00363"></a>00363         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;
<a name="l00364"></a>00364         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">_type</a> (<span class="keyword">const</span> std::basic_string&lt;C&gt;&amp; s,
<a name="l00365"></a>00365                <span class="keyword">const</span> xercesc::DOMElement* e,
<a name="l00366"></a>00366                <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0,
<a name="l00367"></a>00367                <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0);
<a name="l00369"></a>00369 
<a name="l00370"></a>00370       <span class="keyword">public</span>:
<a name="l00377"></a>00377         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">type</a>&amp;
<a name="l00378"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#a074fa4fc0c39ed0227df33ab3fb390dc">00378</a>         operator= (<span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">type</a>&amp; x)
<a name="l00379"></a>00379         {
<a name="l00380"></a>00380           <span class="keywordflow">while</span> (&amp;x == 0) <span class="comment">/* unused */</span>;
<a name="l00381"></a>00381           <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00382"></a>00382         }
<a name="l00383"></a>00383 
<a name="l00384"></a>00384         <span class="comment">// Container API.</span>
<a name="l00385"></a>00385         <span class="comment">//</span>
<a name="l00386"></a>00386       <span class="keyword">public</span>:
<a name="l00394"></a>00394         <span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>*
<a name="l00395"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#a515fc35e21108733f525587a85ac2c3b">00395</a>         _container ()<span class="keyword"> const</span>
<a name="l00396"></a>00396 <span class="keyword">        </span>{
<a name="l00397"></a>00397           <span class="keywordflow">return</span> container_;
<a name="l00398"></a>00398         }
<a name="l00399"></a>00399 
<a name="l00407"></a>00407         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>*
<a name="l00408"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#a30af0e695d94f38a17305f147eb30f9b">00408</a>         _container ()
<a name="l00409"></a>00409         {
<a name="l00410"></a>00410           <span class="keywordflow">return</span> container_;
<a name="l00411"></a>00411         }
<a name="l00412"></a>00412 
<a name="l00419"></a>00419         <span class="keyword">virtual</span> <span class="keywordtype">void</span>
<a name="l00420"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#a9df83a7b4af1d4c89f8ce70a80bef77f">00420</a>         _container (<a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c)
<a name="l00421"></a>00421         {
<a name="l00422"></a>00422           <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* dr (0);
<a name="l00423"></a>00423 
<a name="l00424"></a>00424           <span class="keywordflow">if</span> (c != 0)
<a name="l00425"></a>00425           {
<a name="l00426"></a>00426             dr = c-&gt;<a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#a4b3013d82b0381255eca352caa08ffc6" title="Get a constant pointer to object model&#39;s root node.">_root</a> ();
<a name="l00427"></a>00427 
<a name="l00428"></a>00428             <span class="keywordflow">if</span> (dr == 0)
<a name="l00429"></a>00429               dr = c;
<a name="l00430"></a>00430           }
<a name="l00431"></a>00431 
<a name="l00432"></a>00432           std::auto_ptr&lt;map&gt;&amp; m (dr ? dr-&gt;map_ : map_);
<a name="l00433"></a>00433 
<a name="l00434"></a>00434           <span class="keywordflow">if</span> (container_ == 0)
<a name="l00435"></a>00435           {
<a name="l00436"></a>00436             <span class="keywordflow">if</span> (c != 0 &amp;&amp; map_.get () != 0)
<a name="l00437"></a>00437             {
<a name="l00438"></a>00438               <span class="comment">// Transfer our IDs to the new root.</span>
<a name="l00439"></a>00439               <span class="comment">//</span>
<a name="l00440"></a>00440               <span class="keywordflow">if</span> (m.get () != 0)
<a name="l00441"></a>00441               {
<a name="l00442"></a>00442                 m-&gt;insert (map_-&gt;begin (), map_-&gt;end ());
<a name="l00443"></a>00443                 std::auto_ptr&lt;map&gt; tmp (0);
<a name="l00444"></a>00444                 map_ = tmp;
<a name="l00445"></a>00445               }
<a name="l00446"></a>00446               <span class="keywordflow">else</span>
<a name="l00447"></a>00447                 m = map_;
<a name="l00448"></a>00448             }
<a name="l00449"></a>00449           }
<a name="l00450"></a>00450           <span class="keywordflow">else</span>
<a name="l00451"></a>00451           {
<a name="l00452"></a>00452             <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* sr (_root ());
<a name="l00453"></a>00453 
<a name="l00454"></a>00454             <span class="keywordflow">if</span> (sr-&gt;map_.get () != 0)
<a name="l00455"></a>00455             {
<a name="l00456"></a>00456               <span class="comment">// Transfer IDs that belong to this subtree.</span>
<a name="l00457"></a>00457               <span class="comment">//</span>
<a name="l00458"></a>00458               <span class="keywordflow">for</span> (map::iterator i (sr-&gt;map_-&gt;begin ()), e (sr-&gt;map_-&gt;end ());
<a name="l00459"></a>00459                    i != e;)
<a name="l00460"></a>00460               {
<a name="l00461"></a>00461                 <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">type</a>* x (i-&gt;second);
<a name="l00462"></a>00462                 <span class="keywordflow">for</span> (; x != <span class="keyword">this</span> &amp;&amp; x != sr; x = x-&gt;<a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#a515fc35e21108733f525587a85ac2c3b" title="Get a constant pointer to container, an object model node that contains this instance.">_container</a> ()) ;
<a name="l00463"></a>00463 
<a name="l00464"></a>00464                 <span class="keywordflow">if</span> (x != sr)
<a name="l00465"></a>00465                 {
<a name="l00466"></a>00466                   <span class="comment">// Part of our subtree.</span>
<a name="l00467"></a>00467                   <span class="comment">//</span>
<a name="l00468"></a>00468                   <span class="keywordflow">if</span> (m.get () == 0)
<a name="l00469"></a>00469                   {
<a name="l00470"></a>00470                     std::auto_ptr&lt;map&gt; tmp (<span class="keyword">new</span> map);
<a name="l00471"></a>00471                     m = tmp;
<a name="l00472"></a>00472                   }
<a name="l00473"></a>00473 
<a name="l00474"></a>00474                   m-&gt;insert (*i);
<a name="l00475"></a>00475                   sr-&gt;map_-&gt;erase (i++);
<a name="l00476"></a>00476                 }
<a name="l00477"></a>00477                 <span class="keywordflow">else</span>
<a name="l00478"></a>00478                   ++i;
<a name="l00479"></a>00479               }
<a name="l00480"></a>00480             }
<a name="l00481"></a>00481           }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483           container_ = c;
<a name="l00484"></a>00484         }
<a name="l00485"></a>00485 
<a name="l00492"></a>00492         <span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>*
<a name="l00493"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#a4b3013d82b0381255eca352caa08ffc6">00493</a>         _root ()<span class="keyword"> const</span>
<a name="l00494"></a>00494 <span class="keyword">        </span>{
<a name="l00495"></a>00495           <span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* r (container_);
<a name="l00496"></a>00496 
<a name="l00497"></a>00497           <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c (r); c != 0; c = c-&gt;container_)
<a name="l00498"></a>00498             r = c;
<a name="l00499"></a>00499 
<a name="l00500"></a>00500           <span class="keywordflow">return</span> r;
<a name="l00501"></a>00501         }
<a name="l00502"></a>00502 
<a name="l00509"></a>00509         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>*
<a name="l00510"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#a083e3ed530b093a910bb0983a9b55543">00510</a>         _root ()
<a name="l00511"></a>00511         {
<a name="l00512"></a>00512           <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* r (container_);
<a name="l00513"></a>00513 
<a name="l00514"></a>00514           <span class="keywordflow">for</span> (<a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c (r); c != 0; c = c-&gt;container_)
<a name="l00515"></a>00515             r = c;
<a name="l00516"></a>00516 
<a name="l00517"></a>00517           <span class="keywordflow">return</span> r;
<a name="l00518"></a>00518         }
<a name="l00519"></a>00519 
<a name="l00520"></a>00520         <span class="comment">// DOM association.</span>
<a name="l00521"></a>00521         <span class="comment">//</span>
<a name="l00522"></a>00522       <span class="keyword">public</span>:
<a name="l00529"></a>00529         <span class="keyword">const</span> xercesc::DOMNode*
<a name="l00530"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#a278dc5d809ddf5073960cd1858079359">00530</a>         _node ()<span class="keyword"> const</span>
<a name="l00531"></a>00531 <span class="keyword">        </span>{
<a name="l00532"></a>00532           <span class="keywordflow">return</span> dom_info_.get () ? dom_info_-&gt;node() : 0;
<a name="l00533"></a>00533         }
<a name="l00534"></a>00534 
<a name="l00541"></a>00541         xercesc::DOMNode*
<a name="l00542"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#aa0d266867edb721a5cc4f3968c474756">00542</a>         _node ()
<a name="l00543"></a>00543         {
<a name="l00544"></a>00544           <span class="keywordflow">return</span> dom_info_.get () ? dom_info_-&gt;node () : 0;
<a name="l00545"></a>00545         }
<a name="l00546"></a>00546 
<a name="l00551"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type_1_1bad__dom__node__type.html">00551</a>         <span class="keyword">class </span><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type_1_1bad__dom__node__type.html" title="Exception indicating that a DOM node cannot be associated with an object model node.">bad_dom_node_type</a>: <span class="keyword">public</span> <a class="code" href="namespacexml__schema.html#a1592e5dccfe05c9bc5a1fe3efb8fb54e">std::exception</a> <span class="comment">//@@ Inherit exception.</span>
<a name="l00552"></a>00552         {
<a name="l00553"></a>00553         <span class="keyword">public</span>:
<a name="l00559"></a>00559           <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>*
<a name="l00560"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type_1_1bad__dom__node__type.html#a94cdd00c1d8223a8f8ce215eb425bbfe">00560</a>           what () <span class="keyword">const</span> throw ()
<a name="l00561"></a>00561           {
<a name="l00562"></a>00562             <span class="keywordflow">return</span> <span class="stringliteral">&quot;DOM node is not an attribute node or element node&quot;</span>;
<a name="l00563"></a>00563           }
<a name="l00564"></a>00564         };
<a name="l00565"></a>00565 
<a name="l00578"></a>00578         <span class="keywordtype">void</span>
<a name="l00579"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#ab20ff499ca6365315191bb8ff55a111f">00579</a>         _node (xercesc::DOMNode* n)
<a name="l00580"></a>00580         {
<a name="l00581"></a>00581           <span class="keywordflow">switch</span> (n-&gt;getNodeType ())
<a name="l00582"></a>00582           {
<a name="l00583"></a>00583           <span class="keywordflow">case</span> xercesc::DOMNode::ELEMENT_NODE:
<a name="l00584"></a>00584             {
<a name="l00585"></a>00585               <span class="keywordflow">if</span> (container_ != 0)
<a name="l00586"></a>00586               {
<a name="l00587"></a>00587                 <span class="comment">// @@ Should be a throw.</span>
<a name="l00588"></a>00588                 <span class="comment">//</span>
<a name="l00589"></a>00589                 assert (_root ()-&gt;_node () != 0);
<a name="l00590"></a>00590                 assert (_root ()-&gt;_node ()-&gt;getOwnerDocument () ==
<a name="l00591"></a>00591                         n-&gt;getOwnerDocument ());
<a name="l00592"></a>00592               }
<a name="l00593"></a>00593 
<a name="l00594"></a>00594               std::auto_ptr&lt;dom_info&gt; r (
<a name="l00595"></a>00595                 dom_info_factory::create (
<a name="l00596"></a>00596                   *static_cast&lt;xercesc::DOMElement*&gt; (n),
<a name="l00597"></a>00597                   *<span class="keyword">this</span>,
<a name="l00598"></a>00598                   container_ == 0));
<a name="l00599"></a>00599 
<a name="l00600"></a>00600               dom_info_ = r;
<a name="l00601"></a>00601               <span class="keywordflow">break</span>;
<a name="l00602"></a>00602             }
<a name="l00603"></a>00603           <span class="keywordflow">case</span> xercesc::DOMNode::ATTRIBUTE_NODE:
<a name="l00604"></a>00604             {
<a name="l00605"></a>00605               <span class="comment">//@@ Should be a throw.</span>
<a name="l00606"></a>00606               <span class="comment">//</span>
<a name="l00607"></a>00607               assert (container_ != 0);
<a name="l00608"></a>00608               assert (_root ()-&gt;_node () != 0);
<a name="l00609"></a>00609               assert (_root ()-&gt;_node ()-&gt;getOwnerDocument () ==
<a name="l00610"></a>00610                       n-&gt;getOwnerDocument ());
<a name="l00611"></a>00611 
<a name="l00612"></a>00612               std::auto_ptr&lt;dom_info&gt; r (
<a name="l00613"></a>00613                 dom_info_factory::create (
<a name="l00614"></a>00614                   *static_cast&lt;xercesc::DOMAttr*&gt; (n),
<a name="l00615"></a>00615                   *<span class="keyword">this</span>));
<a name="l00616"></a>00616 
<a name="l00617"></a>00617               dom_info_ = r;
<a name="l00618"></a>00618               <span class="keywordflow">break</span>;
<a name="l00619"></a>00619             }
<a name="l00620"></a>00620           <span class="keywordflow">default</span>:
<a name="l00621"></a>00621             {
<a name="l00622"></a>00622               <span class="keywordflow">throw</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type_1_1bad__dom__node__type.html" title="Exception indicating that a DOM node cannot be associated with an object model node.">bad_dom_node_type</a> ();
<a name="l00623"></a>00623             }
<a name="l00624"></a>00624           }
<a name="l00625"></a>00625         }
<a name="l00626"></a>00626 
<a name="l00627"></a>00627       <span class="keyword">public</span>:
<a name="l00628"></a>00628         <span class="comment">//@cond</span>
<a name="l00629"></a>00629 
<a name="l00630"></a>00630         <span class="keywordtype">void</span>
<a name="l00631"></a>00631         _register_id (<span class="keyword">const</span> identity&amp; <span class="keywordtype">id</span>, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">type</a>* t)
<a name="l00632"></a>00632         {
<a name="l00633"></a>00633           <span class="comment">// We should be the root.</span>
<a name="l00634"></a>00634           <span class="comment">//</span>
<a name="l00635"></a>00635           assert (container_ == 0);
<a name="l00636"></a>00636 
<a name="l00637"></a>00637           <span class="keywordflow">if</span> (map_.get () == 0)
<a name="l00638"></a>00638           {
<a name="l00639"></a>00639             std::auto_ptr&lt;map&gt; tmp (<span class="keyword">new</span> map);
<a name="l00640"></a>00640             map_ = tmp;
<a name="l00641"></a>00641           }
<a name="l00642"></a>00642 
<a name="l00643"></a>00643           <span class="keywordflow">if</span> (!map_-&gt;insert (
<a name="l00644"></a>00644                 std::pair&lt;const identity*, type*&gt; (&amp;<span class="keywordtype">id</span>, t)).second)
<a name="l00645"></a>00645           {
<a name="l00646"></a>00646             <span class="keywordtype">id</span>.throw_duplicate_id ();
<a name="l00647"></a>00647           }
<a name="l00648"></a>00648         }
<a name="l00649"></a>00649 
<a name="l00650"></a>00650         <span class="comment">//@@ Does not inherit from exception.</span>
<a name="l00651"></a>00651         <span class="comment">//</span>
<a name="l00652"></a>00652         <span class="keyword">struct </span>not_registered: <a class="code" href="namespacexml__schema.html#a1592e5dccfe05c9bc5a1fe3efb8fb54e">std::exception</a>
<a name="l00653"></a>00653         {
<a name="l00654"></a>00654           <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>*
<a name="l00655"></a>00655           what () <span class="keyword">const</span> throw ()
<a name="l00656"></a>00656           {
<a name="l00657"></a>00657             <span class="keywordflow">return</span> <span class="stringliteral">&quot;attempt to unregister non-existent id&quot;</span>;
<a name="l00658"></a>00658           }
<a name="l00659"></a>00659         };
<a name="l00660"></a>00660 
<a name="l00661"></a>00661         <span class="keywordtype">void</span>
<a name="l00662"></a>00662         _unregister_id (<span class="keyword">const</span> identity&amp; <span class="keywordtype">id</span>)
<a name="l00663"></a>00663         {
<a name="l00664"></a>00664           <span class="comment">// We should be the root.</span>
<a name="l00665"></a>00665           <span class="comment">//</span>
<a name="l00666"></a>00666           assert (container_ == 0);
<a name="l00667"></a>00667 
<a name="l00668"></a>00668           <span class="keywordflow">if</span> (map_.get () == 0 || map_-&gt;erase (&amp;<span class="keywordtype">id</span>) == 0)
<a name="l00669"></a>00669             <span class="keywordflow">throw</span> not_registered ();
<a name="l00670"></a>00670         }
<a name="l00671"></a>00671 
<a name="l00672"></a>00672         <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#ab1cb97634544f0807153eb2ca9696514" title="Class corresponding to the XML Schema anyType built-in type.">type</a>*
<a name="l00673"></a>00673         _lookup_id (<span class="keyword">const</span> identity&amp; <span class="keywordtype">id</span>)<span class="keyword"> const</span>
<a name="l00674"></a>00674 <span class="keyword">        </span>{
<a name="l00675"></a>00675           <span class="keywordflow">if</span> (map_.get ())
<a name="l00676"></a>00676           {
<a name="l00677"></a>00677             map::const_iterator it (map_-&gt;find (&amp;<span class="keywordtype">id</span>));
<a name="l00678"></a>00678 
<a name="l00679"></a>00679             <span class="keywordflow">if</span> (it != map_-&gt;end ())
<a name="l00680"></a>00680               <span class="keywordflow">return</span> it-&gt;second;
<a name="l00681"></a>00681           }
<a name="l00682"></a>00682 
<a name="l00683"></a>00683           <span class="keywordflow">return</span> 0;
<a name="l00684"></a>00684         }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686         <span class="comment">//@endcond</span>
<a name="l00687"></a>00687 
<a name="l00688"></a>00688       <span class="keyword">private</span>:
<a name="l00689"></a>00689         <span class="comment">//@cond</span>
<a name="l00690"></a>00690 
<a name="l00691"></a>00691         <span class="keyword">struct </span>dom_info
<a name="l00692"></a>00692         {
<a name="l00693"></a>00693           <span class="keyword">virtual</span>
<a name="l00694"></a>00694           ~dom_info ()
<a name="l00695"></a>00695           {
<a name="l00696"></a>00696           }
<a name="l00697"></a>00697 
<a name="l00698"></a>00698           dom_info ()
<a name="l00699"></a>00699           {
<a name="l00700"></a>00700           }
<a name="l00701"></a>00701 
<a name="l00702"></a>00702           <span class="keyword">virtual</span> std::auto_ptr&lt;dom_info&gt;
<a name="l00703"></a>00703           clone (<a class="code" href="namespacexsd_1_1cxx_1_1tree.html#ab1cb97634544f0807153eb2ca9696514" title="Class corresponding to the XML Schema anyType built-in type.">type</a>&amp; tree_node, <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#af4fa7fc8c640fbce1676e7743f2f08bc" title="Container type.">container</a>*) <span class="keyword">const</span> = 0;
<a name="l00704"></a>00704 
<a name="l00705"></a>00705           <span class="keyword">virtual</span> xercesc::DOMNode*
<a name="l00706"></a>00706           node () = 0;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708         <span class="keyword">private</span>:
<a name="l00709"></a>00709           dom_info (<span class="keyword">const</span> dom_info&amp;);
<a name="l00710"></a>00710 
<a name="l00711"></a>00711           dom_info&amp;
<a name="l00712"></a>00712           operator= (<span class="keyword">const</span> dom_info&amp;);
<a name="l00713"></a>00713         };
<a name="l00714"></a>00714 
<a name="l00715"></a>00715 
<a name="l00716"></a>00716         <span class="keyword">struct </span>dom_element_info: <span class="keyword">public</span> dom_info
<a name="l00717"></a>00717         {
<a name="l00718"></a>00718           dom_element_info (xercesc::DOMElement&amp; e, <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#ab1cb97634544f0807153eb2ca9696514" title="Class corresponding to the XML Schema anyType built-in type.">type</a>&amp; n, <span class="keywordtype">bool</span> root)
<a name="l00719"></a>00719               : doc_ (0), e_ (e)
<a name="l00720"></a>00720           {
<a name="l00721"></a>00721             e_.setUserData (user_data_keys::node, &amp;n, 0);
<a name="l00722"></a>00722 
<a name="l00723"></a>00723             <span class="keywordflow">if</span> (root)
<a name="l00724"></a>00724             {
<a name="l00725"></a>00725               <span class="comment">// The caller should have associated a dom::auto_ptr object</span>
<a name="l00726"></a>00726               <span class="comment">// that owns this document with the document node using the</span>
<a name="l00727"></a>00727               <span class="comment">// xml_schema::dom::tree_node_key key.</span>
<a name="l00728"></a>00728               <span class="comment">//</span>
<a name="l00729"></a>00729               xml::dom::auto_ptr&lt;xercesc::DOMDocument&gt;* pd (
<a name="l00730"></a>00730                 <span class="keyword">reinterpret_cast&lt;</span>xml::dom::auto_ptr&lt;xercesc::DOMDocument&gt;*<span class="keyword">&gt;</span> (
<a name="l00731"></a>00731                   e.getOwnerDocument ()-&gt;getUserData (user_data_keys::node)));
<a name="l00732"></a>00732 
<a name="l00733"></a>00733               assert (pd != 0);
<a name="l00734"></a>00734               assert (pd-&gt;get () == e.getOwnerDocument ());
<a name="l00735"></a>00735 
<a name="l00736"></a>00736               doc_ = *pd; <span class="comment">// Transfer ownership.</span>
<a name="l00737"></a>00737             }
<a name="l00738"></a>00738           }
<a name="l00739"></a>00739 
<a name="l00740"></a>00740           <span class="keyword">virtual</span> std::auto_ptr&lt;dom_info&gt;
<a name="l00741"></a>00741           clone (<a class="code" href="namespacexsd_1_1cxx_1_1tree.html#ab1cb97634544f0807153eb2ca9696514" title="Class corresponding to the XML Schema anyType built-in type.">type</a>&amp; tree_node, <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#af4fa7fc8c640fbce1676e7743f2f08bc" title="Container type.">container</a>* c)<span class="keyword"> const</span>
<a name="l00742"></a>00742 <span class="keyword">          </span>{
<a name="l00743"></a>00743             <span class="keyword">using</span> std::auto_ptr;
<a name="l00744"></a>00744 
<a name="l00745"></a>00745             <span class="comment">// Check if we are a document root.</span>
<a name="l00746"></a>00746             <span class="comment">//</span>
<a name="l00747"></a>00747             <span class="keywordflow">if</span> (c == 0)
<a name="l00748"></a>00748             {
<a name="l00749"></a>00749               <span class="comment">// We preserver DOM associations only in complete</span>
<a name="l00750"></a>00750               <span class="comment">// copies from root.</span>
<a name="l00751"></a>00751               <span class="comment">//</span>
<a name="l00752"></a>00752               <span class="keywordflow">if</span> (doc_.get () == 0)
<a name="l00753"></a>00753                 <span class="keywordflow">return</span> auto_ptr&lt;dom_info&gt; (0);
<a name="l00754"></a>00754 
<a name="l00755"></a>00755               <span class="keywordflow">return</span> auto_ptr&lt;dom_info&gt; (
<a name="l00756"></a>00756                 <span class="keyword">new</span> dom_element_info (*doc_, tree_node));
<a name="l00757"></a>00757             }
<a name="l00758"></a>00758 
<a name="l00759"></a>00759             <span class="comment">// Check if our container does not have DOM association (e.g.,</span>
<a name="l00760"></a>00760             <span class="comment">// because it wasn&#39;t a complete copy of the tree).</span>
<a name="l00761"></a>00761             <span class="comment">//</span>
<a name="l00762"></a>00762             <span class="keyword">using</span> xercesc::DOMNode;
<a name="l00763"></a>00763 
<a name="l00764"></a>00764             DOMNode* cn (c-&gt;_node ());
<a name="l00765"></a>00765 
<a name="l00766"></a>00766             <span class="keywordflow">if</span> (cn == 0)
<a name="l00767"></a>00767               <span class="keywordflow">return</span> auto_ptr&lt;dom_info&gt; (0);
<a name="l00768"></a>00768 
<a name="l00769"></a>00769 
<a name="l00770"></a>00770             <span class="comment">// Now we are going to find the corresponding element in</span>
<a name="l00771"></a>00771             <span class="comment">// the new tree.</span>
<a name="l00772"></a>00772             <span class="comment">//</span>
<a name="l00773"></a>00773             {
<a name="l00774"></a>00774               <span class="keyword">using</span> xercesc::DOMElement;
<a name="l00775"></a>00775 
<a name="l00776"></a>00776               DOMNode&amp; pn (*e_.getParentNode ());
<a name="l00777"></a>00777               assert (pn.getNodeType () == DOMNode::ELEMENT_NODE);
<a name="l00778"></a>00778 
<a name="l00779"></a>00779               DOMNode* sn (pn.getFirstChild ()); <span class="comment">// Source.</span>
<a name="l00780"></a>00780               DOMNode* dn (cn-&gt;getFirstChild ()); <span class="comment">// Destination.</span>
<a name="l00781"></a>00781 
<a name="l00782"></a>00782               <span class="comment">// We should have at least one child.</span>
<a name="l00783"></a>00783               <span class="comment">//</span>
<a name="l00784"></a>00784               assert (sn != 0);
<a name="l00785"></a>00785 
<a name="l00786"></a>00786               <span class="comment">// Move in parallel until we get to the needed node.</span>
<a name="l00787"></a>00787               <span class="comment">//</span>
<a name="l00788"></a>00788               <span class="keywordflow">for</span> (; sn != 0 &amp;&amp; !e_.isSameNode (sn);)
<a name="l00789"></a>00789               {
<a name="l00790"></a>00790                 sn = sn-&gt;getNextSibling ();
<a name="l00791"></a>00791                 dn = dn-&gt;getNextSibling ();
<a name="l00792"></a>00792               }
<a name="l00793"></a>00793 
<a name="l00794"></a>00794               <span class="comment">// e_ should be on the list.</span>
<a name="l00795"></a>00795               <span class="comment">//</span>
<a name="l00796"></a>00796               assert (sn != 0);
<a name="l00797"></a>00797 
<a name="l00798"></a>00798               assert (dn-&gt;getNodeType () == DOMNode::ELEMENT_NODE);
<a name="l00799"></a>00799 
<a name="l00800"></a>00800               <span class="keywordflow">return</span> auto_ptr&lt;dom_info&gt; (
<a name="l00801"></a>00801                 <span class="keyword">new</span> dom_element_info (static_cast&lt;DOMElement&amp;&gt; (*dn),
<a name="l00802"></a>00802                                       tree_node,
<a name="l00803"></a>00803                                       <span class="keyword">false</span>));
<a name="l00804"></a>00804             }
<a name="l00805"></a>00805           }
<a name="l00806"></a>00806 
<a name="l00807"></a>00807           <span class="keyword">virtual</span> xercesc::DOMNode*
<a name="l00808"></a>00808           node ()
<a name="l00809"></a>00809           {
<a name="l00810"></a>00810             <span class="keywordflow">return</span> &amp;e_;
<a name="l00811"></a>00811           }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813         <span class="keyword">private</span>:
<a name="l00814"></a>00814           dom_element_info (<span class="keyword">const</span> xercesc::DOMDocument&amp; d, <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#ab1cb97634544f0807153eb2ca9696514" title="Class corresponding to the XML Schema anyType built-in type.">type</a>&amp; n)
<a name="l00815"></a>00815               : doc_ (static_cast&lt;xercesc::DOMDocument*&gt; (
<a name="l00816"></a>00816                         d.cloneNode (true))),
<a name="l00817"></a>00817                 e_ (*doc_-&gt;getDocumentElement ())
<a name="l00818"></a>00818           {
<a name="l00819"></a>00819             e_.setUserData (user_data_keys::node, &amp;n, 0);
<a name="l00820"></a>00820           }
<a name="l00821"></a>00821 
<a name="l00822"></a>00822         <span class="keyword">private</span>:
<a name="l00823"></a>00823           xml::dom::auto_ptr&lt;xercesc::DOMDocument&gt; doc_;
<a name="l00824"></a>00824           xercesc::DOMElement&amp; e_;
<a name="l00825"></a>00825         };
<a name="l00826"></a>00826 
<a name="l00827"></a>00827 
<a name="l00828"></a>00828         <span class="keyword">struct </span>dom_attribute_info: <span class="keyword">public</span> dom_info
<a name="l00829"></a>00829         {
<a name="l00830"></a>00830           dom_attribute_info (xercesc::DOMAttr&amp; a, <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#ab1cb97634544f0807153eb2ca9696514" title="Class corresponding to the XML Schema anyType built-in type.">type</a>&amp; n)
<a name="l00831"></a>00831               : a_ (a)
<a name="l00832"></a>00832           {
<a name="l00833"></a>00833             a_.setUserData (user_data_keys::node, &amp;n, 0);
<a name="l00834"></a>00834           }
<a name="l00835"></a>00835 
<a name="l00836"></a>00836           <span class="keyword">virtual</span> std::auto_ptr&lt;dom_info&gt;
<a name="l00837"></a>00837           clone (<a class="code" href="namespacexsd_1_1cxx_1_1tree.html#ab1cb97634544f0807153eb2ca9696514" title="Class corresponding to the XML Schema anyType built-in type.">type</a>&amp; tree_node, <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#af4fa7fc8c640fbce1676e7743f2f08bc" title="Container type.">container</a>* c)<span class="keyword"> const</span>
<a name="l00838"></a>00838 <span class="keyword">          </span>{
<a name="l00839"></a>00839             <span class="keyword">using</span> std::auto_ptr;
<a name="l00840"></a>00840 
<a name="l00841"></a>00841             <span class="comment">// Check if we are a document root.</span>
<a name="l00842"></a>00842             <span class="comment">//</span>
<a name="l00843"></a>00843             <span class="keywordflow">if</span> (c == 0)
<a name="l00844"></a>00844             {
<a name="l00845"></a>00845               <span class="comment">// We preserver DOM associations only in complete</span>
<a name="l00846"></a>00846               <span class="comment">// copies from root.</span>
<a name="l00847"></a>00847               <span class="comment">//</span>
<a name="l00848"></a>00848               <span class="keywordflow">return</span> auto_ptr&lt;dom_info&gt; (0);
<a name="l00849"></a>00849             }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851             <span class="comment">// Check if our container does not have DOM association (e.g.,</span>
<a name="l00852"></a>00852             <span class="comment">// because it wasn&#39;t a complete copy of the tree).</span>
<a name="l00853"></a>00853             <span class="comment">//</span>
<a name="l00854"></a>00854             <span class="keyword">using</span> xercesc::DOMNode;
<a name="l00855"></a>00855 
<a name="l00856"></a>00856             DOMNode* cn (c-&gt;_node ());
<a name="l00857"></a>00857 
<a name="l00858"></a>00858             <span class="keywordflow">if</span> (cn == 0)
<a name="l00859"></a>00859               <span class="keywordflow">return</span> auto_ptr&lt;dom_info&gt; (0);
<a name="l00860"></a>00860 
<a name="l00861"></a>00861             <span class="comment">// We are going to find the corresponding attribute in</span>
<a name="l00862"></a>00862             <span class="comment">// the new tree.</span>
<a name="l00863"></a>00863             <span class="comment">//</span>
<a name="l00864"></a>00864             <span class="keyword">using</span> xercesc::DOMAttr;
<a name="l00865"></a>00865             <span class="keyword">using</span> xercesc::DOMElement;
<a name="l00866"></a>00866             <span class="keyword">using</span> xercesc::DOMNamedNodeMap;
<a name="l00867"></a>00867 
<a name="l00868"></a>00868             DOMElement&amp; p (*a_.getOwnerElement ());
<a name="l00869"></a>00869             DOMNamedNodeMap&amp; nl (*p.getAttributes ());
<a name="l00870"></a>00870 
<a name="l00871"></a>00871             XMLSize_t size (nl.getLength ()), i (0);
<a name="l00872"></a>00872 
<a name="l00873"></a>00873             <span class="comment">// We should have at least one child.</span>
<a name="l00874"></a>00874             <span class="comment">//</span>
<a name="l00875"></a>00875             assert (size != 0);
<a name="l00876"></a>00876 
<a name="l00877"></a>00877             <span class="keywordflow">for</span> ( ;i &lt; size &amp;&amp; !a_.isSameNode (nl.item (i)); ++i)<span class="comment">/*noop*/</span>;
<a name="l00878"></a>00878 
<a name="l00879"></a>00879             <span class="comment">// a_ should be in the list.</span>
<a name="l00880"></a>00880             <span class="comment">//</span>
<a name="l00881"></a>00881             assert (i &lt; size);
<a name="l00882"></a>00882 
<a name="l00883"></a>00883             DOMNode&amp; n (*cn-&gt;getAttributes ()-&gt;item (i));
<a name="l00884"></a>00884             assert (n.getNodeType () == DOMNode::ATTRIBUTE_NODE);
<a name="l00885"></a>00885 
<a name="l00886"></a>00886             <span class="keywordflow">return</span> auto_ptr&lt;dom_info&gt; (
<a name="l00887"></a>00887               <span class="keyword">new</span> dom_attribute_info (static_cast&lt;DOMAttr&amp;&gt; (n), tree_node));
<a name="l00888"></a>00888           }
<a name="l00889"></a>00889 
<a name="l00890"></a>00890           <span class="keyword">virtual</span> xercesc::DOMNode*
<a name="l00891"></a>00891           node ()
<a name="l00892"></a>00892           {
<a name="l00893"></a>00893             <span class="keywordflow">return</span> &amp;a_;
<a name="l00894"></a>00894           }
<a name="l00895"></a>00895 
<a name="l00896"></a>00896         <span class="keyword">private</span>:
<a name="l00897"></a>00897           xercesc::DOMAttr&amp; a_;
<a name="l00898"></a>00898         };
<a name="l00899"></a>00899 
<a name="l00900"></a>00900         <span class="comment">// For Sun C++ 5.6.</span>
<a name="l00901"></a>00901         <span class="comment">//</span>
<a name="l00902"></a>00902         <span class="keyword">struct </span>dom_info_factory;
<a name="l00903"></a>00903         <span class="keyword">friend</span> <span class="keyword">struct </span>_type::dom_info_factory;
<a name="l00904"></a>00904 
<a name="l00905"></a>00905         <span class="keyword">struct </span>dom_info_factory
<a name="l00906"></a>00906         {
<a name="l00907"></a>00907           <span class="keyword">static</span> std::auto_ptr&lt;dom_info&gt;
<a name="l00908"></a>00908           create (<span class="keyword">const</span> xercesc::DOMElement&amp; e, <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#ab1cb97634544f0807153eb2ca9696514" title="Class corresponding to the XML Schema anyType built-in type.">type</a>&amp; n, <span class="keywordtype">bool</span> root)
<a name="l00909"></a>00909           {
<a name="l00910"></a>00910             <span class="keywordflow">return</span> std::auto_ptr&lt;dom_info&gt; (
<a name="l00911"></a>00911               <span class="keyword">new</span> dom_element_info (
<a name="l00912"></a>00912                 const_cast&lt;xercesc::DOMElement&amp;&gt; (e), n, root));
<a name="l00913"></a>00913           }
<a name="l00914"></a>00914 
<a name="l00915"></a>00915           <span class="keyword">static</span> std::auto_ptr&lt;dom_info&gt;
<a name="l00916"></a>00916           create (<span class="keyword">const</span> xercesc::DOMAttr&amp; a, <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#ab1cb97634544f0807153eb2ca9696514" title="Class corresponding to the XML Schema anyType built-in type.">type</a>&amp; n)
<a name="l00917"></a>00917           {
<a name="l00918"></a>00918             <span class="keywordflow">return</span> std::auto_ptr&lt;dom_info&gt; (
<a name="l00919"></a>00919               <span class="keyword">new</span> dom_attribute_info (
<a name="l00920"></a>00920                 const_cast&lt;xercesc::DOMAttr&amp;&gt; (a), n));
<a name="l00921"></a>00921           }
<a name="l00922"></a>00922         };
<a name="l00923"></a>00923 
<a name="l00924"></a>00924         <span class="comment">//@endcond</span>
<a name="l00925"></a>00925 
<a name="l00926"></a>00926         std::auto_ptr&lt;dom_info&gt; dom_info_;
<a name="l00927"></a>00927 
<a name="l00928"></a>00928 
<a name="l00929"></a>00929         <span class="comment">// ID/IDREF map.</span>
<a name="l00930"></a>00930         <span class="comment">//</span>
<a name="l00931"></a>00931       <span class="keyword">private</span>:
<a name="l00932"></a>00932 
<a name="l00933"></a>00933         <span class="comment">//@cond</span>
<a name="l00934"></a>00934 
<a name="l00935"></a>00935         <span class="keyword">struct </span>identity_comparator
<a name="l00936"></a>00936         {
<a name="l00937"></a>00937           <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> identity* x, <span class="keyword">const</span> identity* y)<span class="keyword"> const</span>
<a name="l00938"></a>00938 <span class="keyword">          </span>{
<a name="l00939"></a>00939             <span class="keywordflow">return</span> x-&gt;before (*y);
<a name="l00940"></a>00940           }
<a name="l00941"></a>00941         };
<a name="l00942"></a>00942 
<a name="l00943"></a>00943         <span class="comment">//@endcond</span>
<a name="l00944"></a>00944 
<a name="l00945"></a>00945         <span class="keyword">typedef</span>
<a name="l00946"></a>00946         std::map&lt;const identity*, type*, identity_comparator&gt;
<a name="l00947"></a>00947         map;
<a name="l00948"></a>00948 
<a name="l00949"></a>00949         std::auto_ptr&lt;map&gt; map_;
<a name="l00950"></a>00950 
<a name="l00951"></a>00951       <span class="keyword">private</span>:
<a name="l00952"></a>00952         <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#af4fa7fc8c640fbce1676e7743f2f08bc" title="Container type.">container</a>* container_;
<a name="l00953"></a>00953       };
<a name="l00954"></a>00954 
<a name="l00955"></a>00955       <span class="keyword">inline</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#aa0e28b25c653f7eca226d0e0a5e70816" title="Default constructor.">_type::</a>
<a name="l00956"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#aeadf4c4387887414b57b8cb9620d87c3">00956</a> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html#aa0e28b25c653f7eca226d0e0a5e70816" title="Default constructor.">      _type</a> (<span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">type</a>&amp; x, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a>, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c)
<a name="l00957"></a>00957           : container_ (c)
<a name="l00958"></a>00958       {
<a name="l00959"></a>00959         <span class="keywordflow">if</span> (x.dom_info_.get ())
<a name="l00960"></a>00960         {
<a name="l00961"></a>00961           std::auto_ptr&lt;dom_info&gt; r (x.dom_info_-&gt;clone (*<span class="keyword">this</span>, c));
<a name="l00962"></a>00962           dom_info_ = r;
<a name="l00963"></a>00963         }
<a name="l00964"></a>00964       }
<a name="l00965"></a>00965 
<a name="l00966"></a>00966 
<a name="l00973"></a>00973       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> B&gt;
<a name="l00974"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1simple__type.html">00974</a>       <span class="keyword">class </span><a class="code" href="classxsd_1_1cxx_1_1tree_1_1simple__type.html" title="Class corresponding to the XML Schema anySimpleType built-in type.">simple_type</a>: <span class="keyword">public</span> B
<a name="l00975"></a>00975       {
<a name="l00976"></a>00976       <span class="keyword">public</span>:
<a name="l00981"></a>00981 
<a name="l00985"></a>00985         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1simple__type.html" title="Class corresponding to the XML Schema anySimpleType built-in type.">simple_type</a> ();
<a name="l00986"></a>00986 
<a name="l00992"></a>00992         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;
<a name="l00993"></a>00993         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1simple__type.html" title="Class corresponding to the XML Schema anySimpleType built-in type.">simple_type</a> (<span class="keyword">const</span> C* s);
<a name="l00994"></a>00994 
<a name="l00995"></a>00995       <span class="keyword">public</span>:
<a name="l01005"></a>01005         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1simple__type.html" title="Class corresponding to the XML Schema anySimpleType built-in type.">simple_type</a> (<span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1simple__type.html" title="Class corresponding to the XML Schema anySimpleType built-in type.">simple_type</a>&amp; x, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0);
<a name="l01006"></a>01006 
<a name="l01018"></a>01018         <span class="keyword">virtual</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1simple__type.html" title="Class corresponding to the XML Schema anySimpleType built-in type.">simple_type</a>*
<a name="l01019"></a>01019         _clone (<a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0) <span class="keyword">const</span>;
<a name="l01020"></a>01020 
<a name="l01021"></a>01021       <span class="keyword">public</span>:
<a name="l01031"></a>01031         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S&gt;
<a name="l01032"></a>01032         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1simple__type.html" title="Class corresponding to the XML Schema anySimpleType built-in type.">simple_type</a> (<a class="code" href="classxsd_1_1cxx_1_1tree_1_1istream.html">istream&lt;S&gt;</a>&amp; s, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0);
<a name="l01033"></a>01033 
<a name="l01042"></a>01042         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1simple__type.html" title="Class corresponding to the XML Schema anySimpleType built-in type.">simple_type</a> (<span class="keyword">const</span> xercesc::DOMElement&amp; e,
<a name="l01043"></a>01043                      <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0,
<a name="l01044"></a>01044                      <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0);
<a name="l01045"></a>01045 
<a name="l01054"></a>01054         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1simple__type.html" title="Class corresponding to the XML Schema anySimpleType built-in type.">simple_type</a> (<span class="keyword">const</span> xercesc::DOMAttr&amp; a,
<a name="l01055"></a>01055                      <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0,
<a name="l01056"></a>01056                      <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0);
<a name="l01057"></a>01057 
<a name="l01067"></a>01067         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;
<a name="l01068"></a>01068         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1simple__type.html" title="Class corresponding to the XML Schema anySimpleType built-in type.">simple_type</a> (<span class="keyword">const</span> std::basic_string&lt;C&gt;&amp; s,
<a name="l01069"></a>01069                      <span class="keyword">const</span> xercesc::DOMElement* e,
<a name="l01070"></a>01070                      <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0,
<a name="l01071"></a>01071                      <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0);
<a name="l01073"></a>01073       };
<a name="l01074"></a>01074 
<a name="l01075"></a>01075 
<a name="l01083"></a>01083       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;
<a name="l01084"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1element__type.html">01084</a>       <span class="keyword">class </span><a class="code" href="classxsd_1_1cxx_1_1tree_1_1element__type.html" title="Base class for element types.">element_type</a>
<a name="l01085"></a>01085       {
<a name="l01086"></a>01086       <span class="keyword">public</span>:
<a name="l01087"></a>01087         <span class="keyword">virtual</span>
<a name="l01088"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1element__type.html#a11c87bc25c7ce96e21bdb4d493c98df7">01088</a>         ~<a class="code" href="classxsd_1_1cxx_1_1tree_1_1element__type.html" title="Base class for element types.">element_type</a> ()
<a name="l01089"></a>01089         {
<a name="l01090"></a>01090         }
<a name="l01091"></a>01091 
<a name="l01102"></a>01102         <span class="keyword">virtual</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1element__type.html" title="Base class for element types.">element_type</a>*
<a name="l01103"></a>01103         _clone (<a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0) <span class="keyword">const</span> = 0;
<a name="l01104"></a>01104 
<a name="l01111"></a>01111         <span class="keyword">virtual</span> <span class="keyword">const</span> std::basic_string&lt;C&gt;&amp;
<a name="l01112"></a>01112         _name () <span class="keyword">const</span> = 0;
<a name="l01113"></a>01113 
<a name="l01121"></a>01121         <span class="keyword">virtual</span> <span class="keyword">const</span> std::basic_string&lt;C&gt;&amp;
<a name="l01122"></a>01122         _namespace () <span class="keyword">const</span> = 0;
<a name="l01123"></a>01123 
<a name="l01130"></a>01130         <span class="keyword">virtual</span> T*
<a name="l01131"></a>01131         _value () = 0;
<a name="l01132"></a>01132 
<a name="l01139"></a>01139         <span class="keyword">virtual</span> <span class="keyword">const</span> T*
<a name="l01140"></a>01140         _value () <span class="keyword">const</span> = 0;
<a name="l01141"></a>01141       };
<a name="l01142"></a>01142 
<a name="l01143"></a>01143 
<a name="l01144"></a>01144       <span class="comment">//@cond</span>
<a name="l01145"></a>01145 
<a name="l01146"></a>01146       <span class="comment">// Extra schema type id to disambiguate certain cases where</span>
<a name="l01147"></a>01147       <span class="comment">// different XML Schema types (e.g., double and decimal) are</span>
<a name="l01148"></a>01148       <span class="comment">// mapped to the same fundamental C++ type (e.g., double).</span>
<a name="l01149"></a>01149       <span class="comment">//</span>
<a name="l01150"></a>01150       <span class="keyword">struct </span>schema_type
<a name="l01151"></a>01151       {
<a name="l01152"></a>01152         <span class="keyword">enum</span> value
<a name="l01153"></a>01153         {
<a name="l01154"></a>01154           other,
<a name="l01155"></a>01155           <a class="code" href="namespacexsd_1_1cxx_1_1parser_1_1validating_1_1bits.html#a1d9408fed322d255e1cd8d1d3a63c619">double_</a>,
<a name="l01156"></a>01156           <a class="code" href="namespacexsd_1_1cxx_1_1parser_1_1validating_1_1bits.html#a911e83945b5c378ecd980255d3b2995e">decimal</a>
<a name="l01157"></a>01157         };
<a name="l01158"></a>01158       };
<a name="l01159"></a>01159 
<a name="l01160"></a>01160       <span class="comment">//@endcond</span>
<a name="l01161"></a>01161 
<a name="l01162"></a>01162 
<a name="l01163"></a>01163       <span class="comment">//@cond</span>
<a name="l01164"></a>01164       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,
<a name="l01165"></a>01165                 <span class="keyword">typename</span> C,
<a name="l01166"></a>01166                 schema_type::value ST = schema_type::other&gt;
<a name="l01167"></a>01167       <span class="keyword">struct </span>traits
<a name="l01168"></a>01168       {
<a name="l01169"></a>01169         <span class="keyword">typedef</span> T <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#ab1cb97634544f0807153eb2ca9696514" title="Class corresponding to the XML Schema anyType built-in type.">type</a>;
<a name="l01170"></a>01170 
<a name="l01171"></a>01171         <span class="keyword">static</span> std::auto_ptr&lt;T&gt;
<a name="l01172"></a>01172         create (<span class="keyword">const</span> xercesc::DOMElement&amp; e, flags f, <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#af4fa7fc8c640fbce1676e7743f2f08bc" title="Container type.">container</a>* c)
<a name="l01173"></a>01173         {
<a name="l01174"></a>01174           <span class="keywordflow">return</span> std::auto_ptr&lt;T&gt; (<span class="keyword">new</span> T (e, f, c));
<a name="l01175"></a>01175         }
<a name="l01176"></a>01176 
<a name="l01177"></a>01177         <span class="keyword">static</span> std::auto_ptr&lt;T&gt;
<a name="l01178"></a>01178         create (<span class="keyword">const</span> xercesc::DOMAttr&amp; a, flags f, <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#af4fa7fc8c640fbce1676e7743f2f08bc" title="Container type.">container</a>* c)
<a name="l01179"></a>01179         {
<a name="l01180"></a>01180           <span class="keywordflow">return</span> std::auto_ptr&lt;T&gt; (<span class="keyword">new</span> T (a, f, c));
<a name="l01181"></a>01181         }
<a name="l01182"></a>01182 
<a name="l01183"></a>01183         <span class="keyword">static</span> std::auto_ptr&lt;T&gt;
<a name="l01184"></a>01184         create (<span class="keyword">const</span> std::basic_string&lt;C&gt;&amp; s,
<a name="l01185"></a>01185                 <span class="keyword">const</span> xercesc::DOMElement* e,
<a name="l01186"></a>01186                 flags f,
<a name="l01187"></a>01187                 <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#af4fa7fc8c640fbce1676e7743f2f08bc" title="Container type.">container</a>* c)
<a name="l01188"></a>01188         {
<a name="l01189"></a>01189           <span class="keywordflow">return</span> std::auto_ptr&lt;T&gt; (<span class="keyword">new</span> T (s, e, f, c));
<a name="l01190"></a>01190         }
<a name="l01191"></a>01191       };
<a name="l01192"></a>01192 
<a name="l01193"></a>01193       <span class="comment">//@endcond</span>
<a name="l01194"></a>01194 
<a name="l01195"></a>01195 
<a name="l01202"></a>01202       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,
<a name="l01203"></a>01203                 <span class="keyword">typename</span> C,
<a name="l01204"></a>01204                 <span class="keyword">typename</span> B,
<a name="l01205"></a>01205                 schema_type::value ST = schema_type::other&gt;
<a name="l01206"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html">01206</a>       <span class="keyword">class </span><a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html" title="Class template that emulates inheritance from a fundamental C++ type.">fundamental_base</a>: <span class="keyword">public</span> B
<a name="l01207"></a>01207       {
<a name="l01208"></a>01208       <span class="keyword">public</span>:
<a name="l01213"></a>01213 
<a name="l01217"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#ac9669933ab04c3ec187aa639583e74ca">01217</a>         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#ac9669933ab04c3ec187aa639583e74ca" title="Default constructor.">fundamental_base</a> ()
<a name="l01218"></a>01218             : facet_table_ (0), x_ ()
<a name="l01219"></a>01219         {
<a name="l01220"></a>01220         }
<a name="l01221"></a>01221 
<a name="l01227"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#a2ab210d742538aeaa7f2afed2e17271f">01227</a>         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#ac9669933ab04c3ec187aa639583e74ca" title="Default constructor.">fundamental_base</a> (T x)
<a name="l01228"></a>01228             : facet_table_ (0), x_ (x)
<a name="l01229"></a>01229         {
<a name="l01230"></a>01230         }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232       <span class="keyword">public</span>:
<a name="l01242"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#a47feb581aef3d8ebbe9afa0d5ddb486a">01242</a>         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#ac9669933ab04c3ec187aa639583e74ca" title="Default constructor.">fundamental_base</a> (<span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html" title="Class template that emulates inheritance from a fundamental C++ type.">fundamental_base</a>&amp; x,
<a name="l01243"></a>01243                           <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0,
<a name="l01244"></a>01244                           <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0)
<a name="l01245"></a>01245             : B (x, f, c), facet_table_ (0), x_ (x.x_)
<a name="l01246"></a>01246         {
<a name="l01247"></a>01247         }
<a name="l01248"></a>01248 
<a name="l01260"></a>01260         <span class="keyword">virtual</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html" title="Class template that emulates inheritance from a fundamental C++ type.">fundamental_base</a>*
<a name="l01261"></a>01261         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#a7c3037ce28a3500c526e69789e88c68f" title="Copy the instance polymorphically.">_clone</a> (<a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0) <span class="keyword">const</span>;
<a name="l01262"></a>01262 
<a name="l01263"></a>01263       <span class="keyword">public</span>:
<a name="l01273"></a>01273         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S&gt;
<a name="l01274"></a>01274         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#ac9669933ab04c3ec187aa639583e74ca" title="Default constructor.">fundamental_base</a> (<a class="code" href="classxsd_1_1cxx_1_1tree_1_1istream.html">istream&lt;S&gt;</a>&amp; s, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0, <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0);
<a name="l01275"></a>01275 
<a name="l01284"></a>01284         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#ac9669933ab04c3ec187aa639583e74ca" title="Default constructor.">fundamental_base</a> (<span class="keyword">const</span> xercesc::DOMElement&amp; e,
<a name="l01285"></a>01285                           <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0,
<a name="l01286"></a>01286                           <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0);
<a name="l01287"></a>01287 
<a name="l01296"></a>01296         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#ac9669933ab04c3ec187aa639583e74ca" title="Default constructor.">fundamental_base</a> (<span class="keyword">const</span> xercesc::DOMAttr&amp; a,
<a name="l01297"></a>01297                           <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0,
<a name="l01298"></a>01298                           <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0);
<a name="l01299"></a>01299 
<a name="l01309"></a>01309         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#ac9669933ab04c3ec187aa639583e74ca" title="Default constructor.">fundamental_base</a> (<span class="keyword">const</span> std::basic_string&lt;C&gt;&amp; s,
<a name="l01310"></a>01310                           <span class="keyword">const</span> xercesc::DOMElement* e,
<a name="l01311"></a>01311                           <a class="code" href="classxsd_1_1cxx_1_1tree_1_1flags.html" title="Parsing and serialization flags.">flags</a> f = 0,
<a name="l01312"></a>01312                           <a class="code" href="classxsd_1_1cxx_1_1tree_1_1__type.html" title="Class corresponding to the XML Schema anyType built-in type.">container</a>* c = 0);
<a name="l01314"></a>01314 
<a name="l01315"></a>01315       <span class="keyword">public</span>:
<a name="l01322"></a>01322         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html" title="Class template that emulates inheritance from a fundamental C++ type.">fundamental_base</a>&amp;
<a name="l01323"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#a6424f102d4a72ac0e59dac76e72a5b94">01323</a>         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#a6424f102d4a72ac0e59dac76e72a5b94" title="Assign an underlying type value to the instance.">operator= </a>(<span class="keyword">const</span> T&amp; x)
<a name="l01324"></a>01324         {
<a name="l01325"></a>01325           <span class="keywordflow">if</span> (&amp;x_ != &amp;x)
<a name="l01326"></a>01326             x_ = x;
<a name="l01327"></a>01327 
<a name="l01328"></a>01328           <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01329"></a>01329         }
<a name="l01330"></a>01330 
<a name="l01331"></a>01331       <span class="keyword">public</span>:
<a name="l01338"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#ae259b03229fbf46d1801062f72120784">01338</a>         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#ae259b03229fbf46d1801062f72120784" title="Implicitly convert the instance to constant reference to the underlying type.">operator const T&amp; </a>()<span class="keyword"> const</span>
<a name="l01339"></a>01339 <span class="keyword">        </span>{
<a name="l01340"></a>01340           <span class="keywordflow">return</span> x_;
<a name="l01341"></a>01341         }
<a name="l01342"></a>01342 
<a name="l01349"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#a133dae2bd32c99b36c4831bccb6b86fe">01349</a>         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#a133dae2bd32c99b36c4831bccb6b86fe" title="Implicitly convert the instance to reference to the underlying type.">operator T&amp; </a>()
<a name="l01350"></a>01350         {
<a name="l01351"></a>01351           <span class="keywordflow">return</span> x_;
<a name="l01352"></a>01352         }
<a name="l01353"></a>01353 
<a name="l01354"></a>01354         <span class="comment">// The following extra conversion operators causes problems on</span>
<a name="l01355"></a>01355         <span class="comment">// some compilers (notably VC 7.1 and 9.0) and are disabled by</span>
<a name="l01356"></a>01356         <span class="comment">// default.</span>
<a name="l01357"></a>01357         <span class="comment">//</span>
<a name="l01358"></a>01358 <span class="preprocessor">#ifdef XSD_TREE_EXTRA_FUND_CONV</span>
<a name="l01359"></a>01359 <span class="preprocessor"></span>
<a name="l01365"></a>01365         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;
<a name="l01366"></a>01366         operator T2 ()<span class="keyword"> const</span>
<a name="l01367"></a>01367 <span class="keyword">        </span>{
<a name="l01368"></a>01368           <span class="keywordflow">return</span> x_;
<a name="l01369"></a>01369         }
<a name="l01370"></a>01370 
<a name="l01376"></a>01376         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;
<a name="l01377"></a>01377         operator T2 ()
<a name="l01378"></a>01378         {
<a name="l01379"></a>01379           <span class="keywordflow">return</span> x_;
<a name="l01380"></a>01380         }
<a name="l01381"></a>01381 <span class="preprocessor">#endif // XSD_TREE_EXTRA_FUND_CONV</span>
<a name="l01382"></a>01382 <span class="preprocessor"></span>
<a name="l01383"></a>01383       <span class="keyword">public</span>:
<a name="l01389"></a>01389         <span class="keyword">const</span> facet*
<a name="l01390"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#ab43e5b1026344e716cf758bc041c7c3a">01390</a>         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#ab43e5b1026344e716cf758bc041c7c3a" title="Get the facet table associated with this type.">_facet_table</a> ()<span class="keyword"> const</span>
<a name="l01391"></a>01391 <span class="keyword">        </span>{
<a name="l01392"></a>01392           <span class="keywordflow">return</span> facet_table_;
<a name="l01393"></a>01393         }
<a name="l01394"></a>01394 
<a name="l01395"></a>01395       <span class="keyword">protected</span>:
<a name="l01401"></a>01401         <span class="keywordtype">void</span>
<a name="l01402"></a><a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#a256843dbafde3c60b339bc7469b25e39">01402</a>         <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html#ab43e5b1026344e716cf758bc041c7c3a" title="Get the facet table associated with this type.">_facet_table</a> (<span class="keyword">const</span> <a class="code" href="structxsd_1_1cxx_1_1tree_1_1facet.html">facet</a>* ft)
<a name="l01403"></a>01403         {
<a name="l01404"></a>01404           facet_table_ = ft;
<a name="l01405"></a>01405         }
<a name="l01406"></a>01406 
<a name="l01407"></a>01407       <span class="keyword">private</span>:
<a name="l01408"></a>01408         <span class="keyword">const</span> <a class="code" href="structxsd_1_1cxx_1_1tree_1_1facet.html">facet</a>* facet_table_;
<a name="l01409"></a>01409         T x_;
<a name="l01410"></a>01410       };
<a name="l01411"></a>01411 
<a name="l01412"></a>01412       <span class="comment">// While thse operators are not normally necessary, they</span>
<a name="l01413"></a>01413       <span class="comment">// help resolve ambiguities between implicit conversion and</span>
<a name="l01414"></a>01414       <span class="comment">// construction.</span>
<a name="l01415"></a>01415       <span class="comment">//</span>
<a name="l01416"></a>01416 
<a name="l01422"></a>01422       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C, <span class="keyword">typename</span> B, schema_type::value ST&gt;
<a name="l01423"></a>01423       <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l01424"></a><a class="code" href="namespacexsd_1_1cxx_1_1tree.html#a727f14cb62ca879a0bea93b07cae3056">01424</a>       <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#a2876872f06ce2f4178a69b12eb5d42f2" title="buffer comparison operator.">operator== </a>(<span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html" title="Class template that emulates inheritance from a fundamental C++ type.">fundamental_base&lt;T, C, B, ST&gt;</a>&amp; x,
<a name="l01425"></a>01425                   <span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html" title="Class template that emulates inheritance from a fundamental C++ type.">fundamental_base&lt;T, C, B, ST&gt;</a>&amp; y)
<a name="l01426"></a>01426       {
<a name="l01427"></a>01427         T x_ (x);
<a name="l01428"></a>01428         T y_ (y);
<a name="l01429"></a>01429         <span class="keywordflow">return</span> x_ == y_;
<a name="l01430"></a>01430       }
<a name="l01431"></a>01431 
<a name="l01437"></a>01437       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C, <span class="keyword">typename</span> B, schema_type::value ST&gt;
<a name="l01438"></a>01438       <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l01439"></a><a class="code" href="namespacexsd_1_1cxx_1_1tree.html#a3fd00aaac0f37aec11946c3f5eea6781">01439</a>       <a class="code" href="namespacexsd_1_1cxx_1_1tree.html#aebacae72b6589a4ef3527054b7225734" title="buffer comparison operator.">operator!= </a>(<span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html" title="Class template that emulates inheritance from a fundamental C++ type.">fundamental_base&lt;T, C, B, ST&gt;</a>&amp; x,
<a name="l01440"></a>01440                   <span class="keyword">const</span> <a class="code" href="classxsd_1_1cxx_1_1tree_1_1fundamental__base.html" title="Class template that emulates inheritance from a fundamental C++ type.">fundamental_base&lt;T, C, B, ST&gt;</a>&amp; y)
<a name="l01441"></a>01441       {
<a name="l01442"></a>01442         T x_ (x);
<a name="l01443"></a>01443         T y_ (y);
<a name="l01444"></a>01444         <span class="keywordflow">return</span> x_ != y_;
<a name="l01445"></a>01445       }
<a name="l01446"></a>01446 
<a name="l01447"></a>01447 
<a name="l01448"></a>01448       <span class="comment">//@cond</span>
<a name="l01449"></a>01449 
<a name="l01450"></a>01450       <span class="comment">// Comparator for enum tables.</span>
<a name="l01451"></a>01451       <span class="comment">//</span>
<a name="l01452"></a>01452       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;
<a name="l01453"></a>01453       <span class="keyword">struct </span>enum_comparator
<a name="l01454"></a>01454       {
<a name="l01455"></a>01455         enum_comparator (<span class="keyword">const</span> C* <span class="keyword">const</span>* table)
<a name="l01456"></a>01456             : table_ (table)
<a name="l01457"></a>01457         {
<a name="l01458"></a>01458         }
<a name="l01459"></a>01459 
<a name="l01460"></a>01460         <span class="keywordtype">bool</span>
<a name="l01461"></a>01461         operator() (std::size_t i, <span class="keyword">const</span> std::basic_string&lt;C&gt;&amp; s)<span class="keyword"> const</span>
<a name="l01462"></a>01462 <span class="keyword">        </span>{
<a name="l01463"></a>01463           <span class="keywordflow">return</span> table_[i] &lt; s;
<a name="l01464"></a>01464         }
<a name="l01465"></a>01465 
<a name="l01466"></a>01466         <span class="keywordtype">bool</span>
<a name="l01467"></a>01467         operator() (<span class="keyword">const</span> std::basic_string&lt;C&gt;&amp; s, std::size_t i)<span class="keyword"> const</span>
<a name="l01468"></a>01468 <span class="keyword">        </span>{
<a name="l01469"></a>01469           <span class="keywordflow">return</span> s &lt; table_[i];
<a name="l01470"></a>01470         }
<a name="l01471"></a>01471 
<a name="l01472"></a>01472         <span class="keywordtype">bool</span>
<a name="l01473"></a>01473         operator() (std::size_t i, std::size_t j)<span class="keyword"> const</span>
<a name="l01474"></a>01474 <span class="keyword">        </span>{
<a name="l01475"></a>01475           <span class="keywordflow">return</span> std::basic_string&lt;C&gt; (table_[i]) &lt; table_[j];
<a name="l01476"></a>01476         }
<a name="l01477"></a>01477 
<a name="l01478"></a>01478       <span class="keyword">private</span>:
<a name="l01479"></a>01479         <span class="keyword">const</span> C* <span class="keyword">const</span>* table_;
<a name="l01480"></a>01480       };
<a name="l01481"></a>01481 
<a name="l01482"></a>01482       <span class="comment">//@endcond</span>
<a name="l01483"></a>01483     }
<a name="l01484"></a>01484   }
<a name="l01485"></a>01485 }
<a name="l01486"></a>01486 
<a name="l01487"></a>01487 <span class="preprocessor">#include &lt;<a class="code" href="elements_8ixx.html">xsd/cxx/tree/elements.ixx</a>&gt;</span>
<a name="l01488"></a>01488 <span class="preprocessor">#include &lt;xsd/cxx/tree/elements.txx&gt;</span>
<a name="l01489"></a>01489 
<a name="l01490"></a>01490 <span class="preprocessor">#endif  // XSD_CXX_TREE_ELEMENTS_HXX</span>
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 23 2012 01:42:05 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
